# Нотация О
Нотация O-большого сообщает о том, какое время выполнения в итоге будет
истинным, если размер входных данных достаточно велик (скорость роста числа операций).  

Мы будем использовать эту нотацию для упрощения функций, исключая лишние константы.
Поэтому, например, вы должны писать O(n) вместо O(3n) или O(n2) вместо O(5n2 + 3n + 2) 

Ниже перечислены некоторые типичные функции О:  
- Постоянные функции O(1).  
- Логарифмические функции O(log n).  
- Линейные функции O(n).  
- Функция n log n: O(n log n).  
- Квадратичные функции O(n^2)  
- Полиномиальные функции O(n^k) для некоторой константы k.
- Экспоненциальные функции O(2^n) 
- Факториальные функции O(n!)  

Пример расчета среднего для функции sumk(k)  
```
import time

def sumk(k):
    start = time.time()
    total = 0
    for i in range(k + 1):
        total = total + i
    end = time.time()
    return total, end - start

def timetrials(func, k, trials=10):
    totaltime = 0
    for i in range(trials):
        totaltime += func(k)[1]
    print("average =%10.7f for k = %d" % (totaltime / trials, k))

timetrials(sumk, 10000)
timetrials(sumk, 100000)
timetrials(sumk, 1000000)
```
## Задача
Есть функция f003(L), где L - число
```
def f003(L):
    x = 0 # 1
    for i in L: # Цикл выполняется n раз.
        for j in L: # Цикл выполняется n раз.
            x += i*j # 3 - две арифметические операции и присваивание.
    return x # 1
```
Проверьте как увеличивается среднее время выполнения для серии из 10 экспериментов и L = 10, 100, 1000

```
*
Стоимости операций указаны в комментариях.
Стоимость внутреннего цикла равна 3n, и он выполняется n раз,
поэтому общая стоимость всего метода в целом равна 3n2 + 2.
Полученный результат необходимо обозначить как O(n2)
и называть этот код алгоритмом, выполняемым за квадратичное время,
или просто квадратичным алгоритмом (quadratic algorithm).
```
